<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1460030457972">{:repl-history {:ide [], :local [&quot;(defn unary [num]\n  (let [x \&quot;1\&quot;]\n       (loop [y num]\n          (when (&gt; y 1)\n            (concat (str x) 1)\n            (recur (- y 1))))\n       ))&quot; &quot;(unary 5)&quot; &quot;(defn unary [num]\n  (let [x \&quot;1\&quot;]\n       (loop [y num]\n          (when (&gt; y 1)\n            (concat (str x) \&quot;1\&quot;)\n            (recur (- y 1))))\n       ))&quot; &quot;(defn unary [num]\n  (let [x \&quot;1\&quot;]\n       (loop [y num]\n          (when (&gt; y 1)\n            (concat (str x) \&quot;1\&quot;)\n            (recur (- y 1))))\n       x))&quot; &quot;(unary 4)&quot; &quot;()&quot; &quot;(defn unary [num]\n  (let [x \&quot;1\&quot;]\n    (concat x \&quot;1\&quot;)\n       x))&quot; &quot;(defn unary [num]\n  (let [x (concat \&quot;1\&quot; \&quot;1\&quot;)]\n       x))&quot; &quot;(unary 3)&quot; &quot;(defn unary [num]\n  (let [x (concat (loop [y num]\n                    (when (&gt; y num)\n                      x\n                      (recur (- y 1)))))]\n       x))&quot; &quot;(defn unary [num]\n  (let [x (concat (loop [y num]\n                    (when (&gt; y num)\n                      (str x)\n                      (recur (- y 1)))))]\n       x))&quot; &quot;(defn unary [num]\n  (let [x (concat (loop [y num]\n                    (when (&gt; y num)\n                      (concat (str x) \&quot;1\&quot;)\n                      (recur (- y 1)))))]\n       x))&quot; &quot;(defn unary [num]\n  (let [x (loop [y num]\n                    (when (&gt; y num)\n                      (concat (str x) \&quot;1\&quot;)\n                      (recur (- y 1))))]\n       x))&quot; &quot;(hash-map {:0101 2 :0202 2})&quot; &quot;(hash-map :key1 1, key2 2)&quot; &quot;(hash-map :key1 1, :key2 2)&quot; &quot;(merge speed {:22 2.1})&quot; &quot;(require '[clojure.string :as str])&quot; &quot;(str/split \&quot;q1w2e3r4t5y6u7i8o9p0\&quot; #\&quot;\\d+\&quot; 5)&quot; &quot;(str/split \&quot;3242342123123123\&quot; #\&quot;\\d+\&quot; 4)&quot; &quot;(str/split \&quot;3242342123123123\&quot; #\&quot;\\d+\&quot; 3)&quot; &quot;(str/split \&quot;3242342123123123\&quot; #\&quot;1\&quot; 3)&quot; &quot;(str/split \&quot;3242342123123123\&quot; #\&quot;1\&quot; 4)&quot; &quot;(subs \&quot;101010110101\&quot; 3 6)&quot; &quot;(subs \&quot;101010110101\&quot; 0 4 8)&quot; &quot;(subs \&quot;101010110101\&quot; 0 4 8 9)&quot; &quot;(subs \&quot;101010110101\&quot; 0 4)&quot; &quot;(defn reocur [agentdna]\n  (let [x 3]\n    (+ x 11))\n  )&quot; &quot;(reocur asdfa)&quot; &quot;(reocur )&quot; &quot;(reocur 2)&quot; &quot;(def mydna \&quot;1010100110101001\&quot;)&quot; &quot;(reocur mydna)&quot; &quot;(defn gen-gean [num ]\n  (def mygean1 \&quot;1 \&quot;)\n  (println mygean1)\n  (loop [x num]\n    (when (&gt; x 1)\n      (def mygean1\n        (str mygean1 (rand-int 2))\n        )\n      (recur (- x 1))))\n  )&quot; &quot;(gen-gean 50)&quot; &quot;(ns dna.gen)&quot; &quot;(gen-gean 3)&quot; &quot;(gen-gean 10)&quot; &quot;(mygean1)&quot; &quot;(str-int mygean1)&quot; &quot;mygean1&quot; &quot;(geans-list)&quot; &quot;geans-list&quot; &quot;(new-gean-list 1)&quot; &quot;(speed :19)&quot; &quot;(colour :150)&quot; &quot;(new-gean-str 3)&quot; &quot;(new-gean-str 5)&quot; &quot;(get-gene speed)&quot; &quot;(get-speed speed)&quot; &quot;(startup 2222)&quot; &quot;(startup 2223)&quot; &quot;(fmlogo)&quot; &quot;(parse-int \&quot;0.6\&quot;)&quot; &quot;(nread-check (nlogo-str))&quot; &quot;(/ 16 15)&quot; &quot;(loop [match (re-find matcher) ;loop starts with 2 set arguments\n       result []]\n  (if-not match\n    result\n    (recur (re-find matcher)    ;loop with 2 new arguments\n           (conj result match))))&quot; &quot;(loop [match 15 ;loop starts with 2 set arguments\n       result []]\n  (if-not (&gt; match 3 )\n    result\n    (recur (- match 3)    ;loop with 2 new arguments\n           (conj result match))))&quot; &quot;(loop [match 15 ;loop starts with 2 set arguments\n       result []]\n  (if-not (&gt; match 3 )\n    result\n    (recur (- match 1)    ;loop with 2 new arguments\n           (conj result match))))&quot; &quot;(loop [match (quot (.indexOf (str test-gene) gene-end) 6) ;loop starts with 2 set arguments\n       result []]\n  (if-not (&gt; match 3 )\n    result\n    (recur (- match 1)    ;loop with 2 new arguments\n           (conj result match))))&quot; &quot;(loop [match (quot (.indexOf (str test-gene) gene-end) 6) ;loop starts with 2 set arguments\n       result []]\n  (if-not (&gt; match (quot (.indexOf (str test-gene) gene-start) 6) )\n    result\n    (recur (- match 1)    ;loop with 2 new arguments\n           (conj result match))))&quot; &quot;(loop [match (quot (.indexOf (str test-gene) gene-end) 6) ;loop starts with 2 set arguments\n       result []]\n  (if-not (&gt; match (quot (.indexOf (str test-gene) gene-start) 6) )\n    result\n    (recur (- match 1)    ;loop with 2 new arguments\n           (conj result (nth test-gene match)))))&quot; &quot;(map-list Transfer-Rna (loop [match (quot (.indexOf (str test-gene) gene-end) 6) ;loop starts with 2 set arguments\n       result []]\n  (if-not (&gt; match (quot (.indexOf (str test-gene) gene-start) 6) )\n    result\n    (recur (- match 1)    ;loop with 2 new arguments\n           (conj result (nth test-gene match))))))&quot; &quot;(range 1000)\n(filter #(or (= (rem % 3) 0) (= (rem % 5) 0)))\n(reduce +)&quot; &quot;((range 1000)\n(filter #(or (= (rem % 3) 0) (= (rem % 5) 0)))\n(reduce +))&quot; &quot;(val-gene test-gene)&quot; &quot;(find-geneEnd test-rnaM')&quot; &quot;test-rnaM'&quot; &quot;(apply str test-rnaM')&quot; &quot;test-rnaM&quot; &quot;(find-geneEnd test-rnaM)&quot; &quot;(second (find-geneEnd test-genome)0&quot; &quot;(second (find-geneEnd test-genome))&quot; &quot;(find-geneEnd test-genome)&quot; &quot;(subs test-genome (find-geneEnd test-genome))&quot; &quot;(subs (str test-genome) (find-geneEnd test-genome))&quot; &quot;(find-geneStart test-rnaM)&quot; &quot;(subs (str test-genome) (find-geneStart test-genome))&quot; &quot;(find-geneStart test-genome)&quot; &quot;(str test-genome)&quot; &quot;(.indexOf (str DNA) 4)&quot; &quot;(str gene-start)&quot; &quot;(.indexOf (str test-genome) \&quot;:1100\&quot;)&quot; &quot;(.indexOf (str test-genome) (str gene-start))&quot; &quot;(subs (str test-genome) (.indexOf (str test-genome) (str gene-start)))&quot; &quot;(find-geneStart test-genome gene-start)&quot; &quot;(find-geneEnd test-genome gene-end)&quot; &quot;(map-list Transfer-Rna\n          (loop [match (quot (.indexOf (str RNA) gene-end) 6)\n                 result []]\n            (if-not (&gt; match (quot (.indexOf (str RNA) gene-start) 6) )\n              result\n              (recur (- match 1)    ;loop with 2 new arguments\n                     (conj result (nth RNA match))))))&quot; &quot;(val-gene test-rnaM)&quot; &quot;(map-list Transfer-Rna\n          (loop [match (quot (.indexOf (str test-genome) gene-end) 6)\n                 result []]\n            (if-not (&gt; match (quot (.indexOf (str test-genome) gene-start) 6) )\n              result\n              (recur (- match 1)    ;loop with 2 new arguments\n                     (conj result (nth test-genome match))))))&quot; &quot;(map-list Transfer-Rna\n          (loop [end (quot (.indexOf (str test-genome) gene-end) 6)\n                 result []]\n            (if-not (&gt; end (quot (.indexOf (str test-genome) gene-start) 6) )\n              result\n              (recur (- end 1)    ;loop with 2 new arguments\n                     (conj result (nth test-genome end))))))&quot; &quot;(loop [end (quot (.indexOf (str test-genome) gene-end) 6)\n       result []]\n  (if-not (&gt; end (quot (.indexOf (str test-genome) gene-start) 6) )\n    result\n    (recur (- end 1)    ;loop with 2 new arguments\n           (conj result (nth test-genome end)))))&quot; &quot;(find-key test-genome 11 3)&quot; &quot;(find-key test-genome 2 4)&quot; &quot;(loop [end1 11\n       result []]\n  (if-not (&gt; end1 4)\n    result\n    (recur (- end1 1)    ;loop with 2 new arguments\n           (conj result (nth test-genome end)))))&quot; &quot;(loop [end1 11\n       result []]\n  (if-not (&gt; end1 4)\n    result\n    (recur (- end1 1)    ;loop with 2 new arguments\n           (conj result (nth test-genome end1)))))&quot; &quot;(find-key test-genome 4 5)&quot; &quot;(find-key test-genome 4 6)&quot; &quot;(find-key test-genome 4 11)&quot; &quot;(val-gen test-genome 4 11)&quot; &quot;(val-gene test-genome 4 11)&quot;], :remote []}}</component>
</project>